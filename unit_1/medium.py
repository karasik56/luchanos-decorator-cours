"""1. Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
2. В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно дополнительных аргументов.
 Попробуйте вызвать функцию в следующих ситуациях и объясните результат:
    2.1 прокинуть в функцию только 1 аргумент
    2.2 прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
    2.3 создать кортеж со значениями и распаковать его при вызове функции с помощью *
    2.4 создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?"""

"""1"""


def medium_func(*args):
    return sum(args)


print(medium_func(1, 2, 3, 4, 5, 6, 7))

"""2"""


def medium_func_2(a, b, c, d, *args, **kwargs):
    return a, b, c, d, args, kwargs


"""2.1"""

medium_func_2(1)
"""Исключение, ожидается 4 обязательных аргумента, прокинут только 1"""

"""2.2"""

medium_func_2(1, 2, 3, 4, a=100)
"""Исключение, множественное значение для аргумента а(1 и 100"""

"""2.3"""

some_tuple = 1, 2, 3, 4, 5, 6, 7
medium_func_2(*some_tuple)
"""Все работает: первые 4 аргумента заняли позиции в обязательных (a, b, c, d ),
 а остальные запаковались в кортеж args"""

"""2.4"""

some_dict = {'w': 1,
             'x': 2,
             'y': 3,
             'z': 4,
             }
medium_func_2(*some_dict)
"""Исключение, словарь мы можем распаковывать в формате 'Ключ-значение', одна * этого не предполагает """
print(medium_func_2(10, 20, 30, 40, **some_dict))
"""Часть с распаковкой словаря отработает отлично, все переданные аргументы осядут в kwargs"""
